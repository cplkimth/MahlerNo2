/*
This file has been generated by Midnight Peach on 2019-01-10 오후 8:04:18.
You may not need to modify this file.
*/

#region
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
#endregion

namespace MahlerNo2.Data
{
	#region Entities

    #region IEntity
    public partial interface IEntity
    {
    }
    #endregion

	#region Untyped Entity
	/// <summary>
	///   모든 엔터티 클래스의 부모 클래스
	/// </summary>
	[DataContract]
	public abstract partial class UntypedEntity
	{
		/// <summary>
		///   부가정보를 저장하기 위한 object 객체
		/// </summary>
		public object EntityTag { get; set; }

		/// <summary>
		///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear()
		{
			Clear(string.Empty, DateTime.Today);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(DateTime defaultDateTime)
		{
			Clear(string.Empty, defaultDateTime);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString"> 기본 string 값 </param>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(string defaultString, DateTime defaultDateTime)
		{
			Type type = GetType();
			PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

			foreach (PropertyInfo propertyInfo in propertyInfoArray)
			{
				if (propertyInfo.CanWrite == false)
					continue;

				if (propertyInfo.PropertyType == typeof (string))
					propertyInfo.SetValue(this, defaultString, null);

				else if (propertyInfo.PropertyType == typeof (DateTime))
					propertyInfo.SetValue(this, defaultDateTime, null);
			}
		}

		/// <summary>
		///   기본키 값들을 구분자(":")로 연결하여 반환한다.
		/// </summary>
		/// <returns> </returns>
		public abstract string PrimaryKeyValues {get;}

		/// <summary>
		/// 엔터티를 대표하는 문자열을 구한다.
		/// </summary>
		public abstract string EntityText { get; }

		/// <summary>
		///   엔터티의 이름을 구한다.
		/// </summary>
		public abstract string GetEntityTypeName();

		partial void IsLogWritable(ref bool? logWritable);

		public virtual bool LogWritable
		{
			get
			{
			bool? logWritable = null;
			IsLogWritable(ref logWritable);

			if (logWritable.HasValue)
				return logWritable.Value;

			return false;
			}
		}

		/// <summary>
		///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
		///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
		/// </summary>
		/// <returns> </returns>
		public virtual string ToEntityLog()
		{
			const int MaxLength = 2000; // 최대 2000자 까지만 저장.

			Type type = GetType();

			var propertyInfoes = type.GetProperties();

			StringBuilder builder = new StringBuilder(ToString());

			builder.AppendLine();
			foreach (var propertyInfo in propertyInfoes)
			{
				if (propertyInfo.PropertyType != typeof (int))
					continue;

				if (propertyInfo.Name.EndsWith("Code") == false)
					continue;

				string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
				string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

				if (textValue != null)
					builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
			}

			if (builder.Length > MaxLength)
				return builder.ToString(0, MaxLength);
			else
				return builder.ToString();
		}

		private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
		{
			var propertyInfo = objectType.GetProperty(textPropertyName);
			object propertyValue = propertyInfo.GetValue(entity, null);

			if (propertyValue is string)
				return (string) propertyValue;
			else
				return null;
		}
	}
	#endregion

	#region Entity<T>
	/// <summary>
	/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
	/// </summary>
	/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
	[DataContract]
	public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
	{
		/// <summary>
		/// 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public abstract T Clone();

		#region Implementation of IEditableObject

		protected T _clone = null;

		/// <summary>
		/// IEditableObject.BeginEdit 구현
		/// </summary>
		public void BeginEdit()
		{
			if (_clone == null)
				_clone = Clone();
		}

		/// <summary>
		/// IEditableObject.EndEdit 구현
		/// </summary>
		public void EndEdit()
		{
			_clone = null;
		}

		public abstract void CancelEdit();

	#endregion
	}

	#endregion

		#region BreakTime
	/// <summary>
	/// BreakTime 엔터티
	/// </summary>
	public partial class BreakTime : Entity<BreakTime>, IEntity
	{
		public const string EntityTypeName = "BreakTime";

		public static void Copy(BreakTime source, BreakTime target)
		{
						target.No = source.No;		
			target.At = source.At;
		}

		/// <summary>
		/// BreakTime 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override BreakTime Clone()
		{
			var clone = new BreakTime();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// BreakTime 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[No]" + No + ", " + "[At]" + At;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", No); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// BreakTime 엔터티의 컬럼 이름을 상수 멤버로 가지고 있는 클래스
	/// </summary>
	public static class BreakTimeColumnName
	{
				public const string No = "No";
		public const string At = "At";
	}

	/// <summary>
	/// BreakTime 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum BreakTimeColumn
	{
				No,
		At
	}

	
	/// <summary>
	/// BreakTime 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<BreakTime> 구현)
	/// </summary>
	public class BreakTimeEqualityComparer : IEqualityComparer<BreakTime>
	{
		public bool Equals(BreakTime x, BreakTime y)
		{
			return x.No == y.No;
		}

		public int GetHashCode(BreakTime obj)
		{
			return obj.No.GetHashCode();
		}
	}
	
	#endregion
	#region Emoticon
	/// <summary>
	/// Emoticon 엔터티
	/// </summary>
	public partial class Emoticon : Entity<Emoticon>, IEntity
	{
		public const string EntityTypeName = "Emoticon";

		public static void Copy(Emoticon source, Emoticon target)
		{
						target.EmoticonId = source.EmoticonId;		
			target.At = source.At;		
			target.EmoticonCode = source.EmoticonCode;
		}

		/// <summary>
		/// Emoticon 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Emoticon Clone()
		{
			var clone = new Emoticon();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Emoticon 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[EmoticonId]" + EmoticonId + ", " + "[At]" + At + ", " + "[EmoticonCode]" + EmoticonCode;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", EmoticonId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Emoticon 엔터티의 컬럼 이름을 상수 멤버로 가지고 있는 클래스
	/// </summary>
	public static class EmoticonColumnName
	{
				public const string EmoticonId = "EmoticonId";
		public const string At = "At";
		public const string EmoticonCode = "EmoticonCode";
	}

	/// <summary>
	/// Emoticon 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum EmoticonColumn
	{
				EmoticonId,
		At,
		EmoticonCode
	}

	
	/// <summary>
	/// Emoticon 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Emoticon> 구현)
	/// </summary>
	public class EmoticonEqualityComparer : IEqualityComparer<Emoticon>
	{
		public bool Equals(Emoticon x, Emoticon y)
		{
			return x.EmoticonId == y.EmoticonId;
		}

		public int GetHashCode(Emoticon obj)
		{
			return obj.EmoticonId.GetHashCode();
		}
	}
	
	#endregion
	#region Shot
	/// <summary>
	/// Shot 엔터티
	/// </summary>
	public partial class Shot : Entity<Shot>, IEntity
	{
		public const string EntityTypeName = "Shot";

		public static void Copy(Shot source, Shot target)
		{
						target.At = source.At;		
			target.Data = source.Data;		
			target.Note = source.Note;
		}

		/// <summary>
		/// Shot 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Shot Clone()
		{
			var clone = new Shot();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Shot 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[At]" + At + ", " + "[Data]" + Data + ", " + "[Note]" + Note;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", At); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Shot 엔터티의 컬럼 이름을 상수 멤버로 가지고 있는 클래스
	/// </summary>
	public static class ShotColumnName
	{
				public const string At = "At";
		public const string Data = "Data";
		public const string Note = "Note";
	}

	/// <summary>
	/// Shot 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ShotColumn
	{
				At,
		Data,
		Note
	}

	
	/// <summary>
	/// Shot 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Shot> 구현)
	/// </summary>
	public class ShotEqualityComparer : IEqualityComparer<Shot>
	{
		public bool Equals(Shot x, Shot y)
		{
			return x.At == y.At;
		}

		public int GetHashCode(Shot obj)
		{
			return obj.At.GetHashCode();
		}
	}
	
	#endregion
	#region Speech
	/// <summary>
	/// Speech 엔터티
	/// </summary>
	public partial class Speech : Entity<Speech>, IEntity
	{
		public const string EntityTypeName = "Speech";

		public static void Copy(Speech source, Speech target)
		{
						target.SpeechId = source.SpeechId;		
			target.Text = source.Text;
		}

		/// <summary>
		/// Speech 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Speech Clone()
		{
			var clone = new Speech();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Speech 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[SpeechId]" + SpeechId + ", " + "[Text]" + Text;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", SpeechId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Speech 엔터티의 컬럼 이름을 상수 멤버로 가지고 있는 클래스
	/// </summary>
	public static class SpeechColumnName
	{
				public const string SpeechId = "SpeechId";
		public const string Text = "Text";
	}

	/// <summary>
	/// Speech 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum SpeechColumn
	{
				SpeechId,
		Text
	}

	
	/// <summary>
	/// Speech 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Speech> 구현)
	/// </summary>
	public class SpeechEqualityComparer : IEqualityComparer<Speech>
	{
		public bool Equals(Speech x, Speech y)
		{
			return x.SpeechId == y.SpeechId;
		}

		public int GetHashCode(Speech obj)
		{
			return obj.SpeechId.GetHashCode();
		}
	}
	
	#endregion

	#endregion

	#region PropertyChangedEventArgs
	/// <summary>
	/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경된 엔티티
		/// </summary>
		public T Entity { get; set; }

		public PropertyChangedEventArgs(T entity)
		{
			Entity = entity;
		}
	}

	/// <summary>
	/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="K"></typeparam>
	public class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경될 엔티티
		/// </summary>
		public T Entity { get; set; }

		/// <summary>
		/// 새로 변경 될 속성 값
		/// </summary>
		public K Value { get; set; }

		public PropertyChangingEventArgs(T entity, K value)
		{
			Entity = entity;
			Value = value;
		}
	}
	#endregion

	#region Data

	#region EntityData<T>
	[DataObject(true)]
	public abstract partial class EntityData<T> where T : Entity<T>, new()
	{
		internal EntityData() { }

		#region Create
		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create()
		{
			return Create(string.Empty, DateTime.Today);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(DateTime defaultDateTime)
		{
			return Create(string.Empty, defaultDateTime);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString">기본 string 값</param>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(string defaultString, DateTime defaultDateTime)
		{
			T entity = new T();
			entity.Clear(defaultString, defaultDateTime);

			return entity;
		}
		#endregion

		#region Get
		/// <summary>
		/// 모든 엔터티를 반환한다.
		/// </summary>
		/// <returns>엔터티의 리스트</returns>
		public virtual List<T> Get()
		{
			return Get<T>(null, null, false, 0, int.MaxValue);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티들을 반환한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 리스트</returns>
		public List<T> Get(Expression<Func<T, bool>> where)
		{
			return Get<T>(where, null, false, 0, int.MaxValue);
		}

		/// <summary>
		/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
		public List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(null, orderBy, ascending, 0, int.MaxValue);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
		public List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			return Get(null, orderBy, ascending, startRowIndex, maximumRows);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
		public List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(where, orderBy, ascending, 0, int.MaxValue);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
		public List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			using (var context = DbContextFactory.Create())
			{
				return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
			}
		}
		#endregion

		#region select
		/// <summary>
		///   모든 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public virtual List<R> Select<R>(Expression<Func<T, R>> select)
		{
			return Select<T, R>(null, null, false, 0, int.MaxValue, select);
		}

		/// <summary>
		///   조건식에 맞는 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return Select<T, R>(where, null, false, 0, int.MaxValue, select);
		}

		/// <summary>
		///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, 0, int.MaxValue, select);
		}

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		}

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(where, orderBy, ascending, 0, int.MaxValue, select);
		}

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
		public List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
				return query.Select(select).ToList();
			}
		}

		private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, MahlerNo2Entities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

			IOrderedQueryable<T> orderedQuery = null;

			if (orderBy != null)
				orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

			if (startRowIndex != 0 || maximumRows != int.MaxValue)
			{
				if (orderedQuery != null)
					orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
				else
					query = query.Skip(startRowIndex).Take(maximumRows);
			}

			return orderedQuery ?? query;
		}
		#endregion

		#region GetFirst / GetLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <returns>엔터티</returns>
		public virtual T GetFirst()
		{
			return GetFirst<T>(null, null);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티</returns>
		public T GetFirst(Expression<Func<T, bool>> where)
		{
			return GetFirst<T>(where, null);
		}

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		public T GetFirst<U>(Expression<Func<T, U>> orderBy)
		{
			return GetFirst(null, orderBy);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		public T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, true);
		}

	    private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
	        }
	    }

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <returns>엔터티</returns>
        public T GetLast<U>(Expression<Func<T, U>> orderBy)
		{
			return GetLast(null, orderBy);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		public T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, false);
        }

        private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, MahlerNo2Entities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

            // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
            if (orderBy != null)
			    query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

            return query;
		}
		#endregion

		#region SelectFirst / SelectLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
		public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(null, null, select);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
		public R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(where, null, select);
		}

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
		public R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
			return SelectFirst(null, orderBy, select);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
		public R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
		    return SelectFirstCore(where, orderBy, select, true);
		}

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
        /// <returns>엔터티</returns>
        private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = QueryFirst(where, orderBy, ascending, context);
				return query.Select(select).FirstOrDefault();
			}
		}

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectLast(null, orderBy, select);
	    }

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectFirstCore(where, orderBy, select, false);
	    }
        #endregion


		#region GetCount
		/// <summary>
		/// 모든 엔터티의 갯수를 구한다.
		/// </summary>
		/// <returns>엔터티의 갯수</returns>
		public virtual int GetCount()
		{
			return GetCount(null);
		}

		/// <summary>
		/// 조건식에 맞는 엔터티의 갯수를 구한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 갯수</returns>
		public int GetCount(Expression<Func<T, bool>> where)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from item in context.Set<T>()
							select item;

				if (where != null)
					query = query.Where(where);

				return query.Count();
			}
		}
		#endregion

		#region Exist
		/// <summary>
		/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>존재 여부</returns>
		public bool Exists(Expression<Func<T, bool>> where)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from item in context.Set<T>()
							select item;

				if (where != null)
					query = query.Where(where);

				return query.Any();
			}
		}
		#endregion

		#region Write log partial methods
		/// <summary>
		/// 엔티티의 로그를 기록한다.
		/// </summary>
		/// <param name="entity">엔티티</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteSingleLog(T entity, LogType logType);

		/// <summary>
		/// 엔티티 컬렉션의 로그를 기록한다.
		/// </summary>
		/// <param name="entities">엔티티 컬렉션</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteMultipleLog(List<T> entities, LogType logType);
		#endregion

		#region Insert / Update / Delete
		/// <summary>
		/// 엔터티를 삽입한다.
		/// </summary>
		/// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
		public virtual T Insert(T entity)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToInsert(context, entity);

				context.SaveChanges();

				WriteSingleLog(entity, LogType.Insert);

				return entity;
			}
		}

		internal virtual void MarkToInsert(MahlerNo2Entities context, T entity)
		{
			context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티 컬렉션을 삽입한다.
		/// </summary>
		/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string InsertMany(List<T> entities)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToInsertMany(context, entities);

				context.SaveChanges();

				WriteMultipleLog(entities, LogType.Insert);

				return null;
			}
		}

		internal virtual void MarkToInsertMany(MahlerNo2Entities context, List<T> entities)
		{
			foreach (var entity in entities)
				context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티를 갱신한다.
		/// </summary>
		/// <param name="entity">갱신할 엔터티</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string Update(T entity)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToUpdate(context, entity);

				context.SaveChanges();

				WriteSingleLog(entity, LogType.Update);

				return null;
			}
		}

		internal virtual void MarkToUpdate(MahlerNo2Entities context, T entity)
		{
			context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티 컬렉션을 갱신한다.
		/// </summary>
		/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string UpdateMany(List<T> entities)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToUpdateMany(context, entities);

				context.SaveChanges();

				WriteMultipleLog(entities, LogType.Update);

				return null;
			}
		}

		internal virtual void MarkToUpdateMany(MahlerNo2Entities context, List<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티를 삭제한다.
		/// </summary>
		/// <param name="entity">삭제할 엔터티</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string Delete(T entity)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToDelete(context, entity);

				context.SaveChanges();

				WriteSingleLog(entity, LogType.Delete);
				
				return null;
			}
		}

		internal virtual void MarkToDelete(MahlerNo2Entities context, T entity)
		{
			context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 엔터티 컬렉션을 삭제한다.
		/// </summary>
		/// <param name="entities">삭제할 엔터티 컬렉션</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteMany(List<T> entities)
		{
			using (var context = DbContextFactory.Create())
			{
				MarkToDeleteMany(context, entities);

				context.SaveChanges();

				WriteMultipleLog(entities, LogType.Delete);

				return null;
			}
		}

		internal virtual void MarkToDeleteMany(MahlerNo2Entities context, List<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 조건식을 만족하는 엔터티들을 삭제한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteAll(Expression<Func<T, bool>> where)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from item in context.Set<T>()
							select item;

				if (where != null)
					query = query.Where(where);

				var entities = query.ToList();

				MarkToDeleteMany(context, entities);

				context.SaveChanges();

				WriteMultipleLog(entities, LogType.Delete);

				return null;
			}
		}
		#endregion
	}
	#endregion

		#region BreakTimeData
	/// <summary>
	/// BreakTime 데이터 클래스
	/// </summary>
	public partial class BreakTimeData : EntityData<BreakTime>
	{
		internal BreakTimeData() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="no">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
		public virtual BreakTime GetByPK(System.Int32 No)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<BreakTime>().FirstOrDefault(x =>  x.No == No);
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="no">기본키</param>
		/// <returns>존재 여부</returns>
		public virtual bool ExistsByPK(System.Int32 No)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<BreakTime>().Count(x =>  x.No == No) > 0;
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="no">기본키</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteByPK(System.Int32 no)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from x in context.Set<BreakTime>()
				where x.No == no
				select x;

				var entity = query.FirstOrDefault();

				if (entity == null)
					return "There is no entity with the primary key(s).";

				MarkToDelete(context, entity);

				context.SaveChanges();

				return null;
			}
		}

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
	    public virtual BreakTime InsertIfNotExist(BreakTime entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<BreakTime>().Count(x =>  x.No == entity.No) > 0)
	                return null;

	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;
            }
	    }

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
	    public virtual BreakTime InsertOrUpdate(BreakTime entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<BreakTime>().Count(x =>  x.No == entity.No) > 0)
	            {
	                MarkToUpdate(context, entity);
	                context.SaveChanges();

	                return entity;

                }
                else
	            {
	                MarkToInsert(context, entity);
	                context.SaveChanges();

	                return entity;

                }
            }
	    }
		

		
	}
	#endregion
	#region EmoticonData
	/// <summary>
	/// Emoticon 데이터 클래스
	/// </summary>
	public partial class EmoticonData : EntityData<Emoticon>
	{
		internal EmoticonData() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="emoticonId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
		public virtual Emoticon GetByPK(System.Int32 EmoticonId)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Emoticon>().FirstOrDefault(x =>  x.EmoticonId == EmoticonId);
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="emoticonId">기본키</param>
		/// <returns>존재 여부</returns>
		public virtual bool ExistsByPK(System.Int32 EmoticonId)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Emoticon>().Count(x =>  x.EmoticonId == EmoticonId) > 0;
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="emoticonId">기본키</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteByPK(System.Int32 emoticonId)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from x in context.Set<Emoticon>()
				where x.EmoticonId == emoticonId
				select x;

				var entity = query.FirstOrDefault();

				if (entity == null)
					return "There is no entity with the primary key(s).";

				MarkToDelete(context, entity);

				context.SaveChanges();

				return null;
			}
		}

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
	    public virtual Emoticon InsertIfNotExist(Emoticon entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Emoticon>().Count(x =>  x.EmoticonId == entity.EmoticonId) > 0)
	                return null;

	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;
            }
	    }

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
	    public virtual Emoticon InsertOrUpdate(Emoticon entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Emoticon>().Count(x =>  x.EmoticonId == entity.EmoticonId) > 0)
	            {
	                MarkToUpdate(context, entity);
	                context.SaveChanges();

	                return entity;

                }
                else
	            {
	                MarkToInsert(context, entity);
	                context.SaveChanges();

	                return entity;

                }
            }
	    }
		

		
	}
	#endregion
	#region ShotData
	/// <summary>
	/// Shot 데이터 클래스
	/// </summary>
	public partial class ShotData : EntityData<Shot>
	{
		internal ShotData() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="at">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
		public virtual Shot GetByPK(System.DateTime At)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Shot>().FirstOrDefault(x =>  x.At == At);
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="at">기본키</param>
		/// <returns>존재 여부</returns>
		public virtual bool ExistsByPK(System.DateTime At)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Shot>().Count(x =>  x.At == At) > 0;
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="at">기본키</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteByPK(System.DateTime at)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from x in context.Set<Shot>()
				where x.At == at
				select x;

				var entity = query.FirstOrDefault();

				if (entity == null)
					return "There is no entity with the primary key(s).";

				MarkToDelete(context, entity);

				context.SaveChanges();

				return null;
			}
		}

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
	    public virtual Shot InsertIfNotExist(Shot entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Shot>().Count(x =>  x.At == entity.At) > 0)
	                return null;

	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;
            }
	    }

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
	    public virtual Shot InsertOrUpdate(Shot entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Shot>().Count(x =>  x.At == entity.At) > 0)
	            {
	                MarkToUpdate(context, entity);
	                context.SaveChanges();

	                return entity;

                }
                else
	            {
	                MarkToInsert(context, entity);
	                context.SaveChanges();

	                return entity;

                }
            }
	    }
		

		
	}
	#endregion
	#region SpeechData
	/// <summary>
	/// Speech 데이터 클래스
	/// </summary>
	public partial class SpeechData : EntityData<Speech>
	{
		internal SpeechData() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="speechId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
		public virtual Speech GetByPK(System.Int32 SpeechId)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Speech>().FirstOrDefault(x =>  x.SpeechId == SpeechId);
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="speechId">기본키</param>
		/// <returns>존재 여부</returns>
		public virtual bool ExistsByPK(System.Int32 SpeechId)
		{
			using (var context = DbContextFactory.Create())
			{
			return context.Set<Speech>().Count(x =>  x.SpeechId == SpeechId) > 0;
			}
		}

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="speechId">기본키</param>
		/// <returns>예외 메시지. 성공이면 null</returns>
		public virtual string DeleteByPK(System.Int32 speechId)
		{
			using (var context = DbContextFactory.Create())
			{
				var query = from x in context.Set<Speech>()
				where x.SpeechId == speechId
				select x;

				var entity = query.FirstOrDefault();

				if (entity == null)
					return "There is no entity with the primary key(s).";

				MarkToDelete(context, entity);

				context.SaveChanges();

				return null;
			}
		}

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
	    public virtual Speech InsertIfNotExist(Speech entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Speech>().Count(x =>  x.SpeechId == entity.SpeechId) > 0)
	                return null;

	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;
            }
	    }

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
	    public virtual Speech InsertOrUpdate(Speech entity)
	    {
	        using (var context = DbContextFactory.Create())
	        {
	            if (context.Set<Speech>().Count(x =>  x.SpeechId == entity.SpeechId) > 0)
	            {
	                MarkToUpdate(context, entity);
	                context.SaveChanges();

	                return entity;

                }
                else
	            {
	                MarkToInsert(context, entity);
	                context.SaveChanges();

	                return entity;

                }
            }
	    }
		

		
	}
	#endregion
	#endregion

	#region Types
	/// <summary>
	/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
	/// </summary>
	public enum LogType
	{
		/// <summary>
		/// 엔티티 삽입
		/// </summary>
		Insert,

		/// <summary>
		/// 엔티티 컬렉션 삽입
		/// </summary>
		InsertMany,

		/// <summary>
		/// 엔티티 갱신
		/// </summary>
		Update,

		/// <summary>
		/// 엔티티 컬렉션 갱신
		/// </summary>
		UpdateMany,

		/// <summary>
		/// 엔티티 삭제
		/// </summary>
		Delete,

		/// <summary>
		/// 엔티티 컬렉션 삭제
		/// </summary>
		DeleteMany
	}
	#endregion

	#region DataRepositoryBase
	/// <summary>
	/// DataRepository의 부모. DataRepository를 확장하는 용도로 사용한다.
	/// </summary>
	public partial class DataRepositoryBase
	{
	}
	#endregion

	#region DataRepository
	/// <summary>
	/// 각 엔터티 데이터 객체의 모음
	/// </summary>
	public partial class DataRepository : DataRepositoryBase
	{
		static DataRepository()
		{
						BreakTime = new BreakTimeData();					Emoticon = new EmoticonData();					Shot = new ShotData();					Speech = new SpeechData();
		}

		#region Data objects
				public static BreakTimeData BreakTime { get; private set; }				public static EmoticonData Emoticon { get; private set; }				public static ShotData Shot { get; private set; }				public static SpeechData Speech { get; private set; }
		#endregion
		}
	#endregion

	#region DbContextFactory
	/// <summary>
	/// MahlerNo2Entities객체 생성기
	/// </summary>
	public partial class DbContextFactory
	{
		/// <summary>
		/// MP에서 설정된 연결 문자열을 오버라이드 한다.
		/// </summary>
		/// <param name="connectionString"></param>
		static partial void GetConnectionStringCore(ref string connectionString);

	    /// <summary>
        /// MahlerNo2Entities 객체가 생성되었을 때 호출된다.
        /// </summary>
        /// <param name="context">생성된 MahlerNo2Entities 객체</param>
	    static partial void OnCreated(MahlerNo2Entities context);

		/// <summary>
		/// 연결 문자열을 생성한다. GetConnectionStringCore 부분 메서드를 구현하지 않으면 MP에서 설정된 값을 사용한다.
		/// </summary>
		/// <returns></returns>
		public static string GetConnectionString()
		{
			string connectionString = string.Empty;

			GetConnectionStringCore(ref connectionString);

			if (string.IsNullOrEmpty(connectionString))
			return "name=MahlerNo2Entities";
			else
			return connectionString;
		}

		/// <summary>
		/// MahlerNo2Entities 객체를 생성한다.
		/// </summary>
		/// <returns></returns>
	    public static MahlerNo2Entities Create(bool lazyLoadingEnabled = false, bool proxyCreationEnabled = false, bool autoDetectChangesEnabled = false)
	    {
	        string connectionString = GetConnectionString();

	        var context = new MahlerNo2Entities(connectionString);

	        context.Configuration.LazyLoadingEnabled = lazyLoadingEnabled;
	        context.Configuration.ProxyCreationEnabled = proxyCreationEnabled;
	        context.Configuration.AutoDetectChangesEnabled = autoDetectChangesEnabled;

	        CreateCore(context);

	        return context;
	    }

	    /// <summary>
	    /// MahlerNo2Entities 객체의 옵션을 설정한다.
	    /// </summary>
	    /// <param name="context">생성된 MahlerNo2Entities 객체</param>
	    static partial void CreateCore(MahlerNo2Entities context);
	}
	#endregion

	#region MahlerNo2Entities
	public partial class MahlerNo2Entities
	{
	    internal MahlerNo2Entities(string nameOrConnectionString) : base(nameOrConnectionString)
	    {
	    }

	    public List<string> ValidationErrorMessages
	    {
	        get
	        {
	            return GetValidationErrors()
	            .SelectMany(x => x.ValidationErrors)
	            .Select(x => $"[{x.PropertyName}] {x.ErrorMessage}")
	            .ToList();
	        }
	    }

	    public string ValidationErrorMessage => string.Join(Environment.NewLine, ValidationErrorMessages);
	    }
	#endregion
}